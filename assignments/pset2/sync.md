# Synchronization Questions
[back to table of contents](/assignments/pset2/contents.md)

## 1. Partial Matching
The difference in the arguments for the shortenUrl actions lies in the fact that they define two entirely different behaviors and have different goals.

In the first sync, its whole purpose is to describe the sync of *creating a unique string for a shortUrlBase context* once a request to shorten a URL goes through. It does NOTHING else except begin the process of getting this nonce string. This is why it only has shortUrlBase in the request arguments, because that is all it needs to perform this sync. shortUrlBase is treated as one of the contexts defined in the NonceGeneration concept, and we generate a string in the then statement.

In the second sync, our goal is to actually *register a shortened URL that goes to some target URL*. To do this, we need both targetUrl and shortUrlBase. It should be noted that this sync only happens once a request for a shortened URL goes through. However, what makes its conditions different from the first sync is that a nonce was already generated by some prior nonce generation (perhaps even by a generate sync). The registration of a shortened URL is then begun in the then statement.

## 2. Omitting Names
We cannot always have argument names be the same as variable names. The reason why we can't use the convention all the time is because it may make us(the programmer) have a harder time keeping track of what specifically is being passed between functions. For example, in the second sync, we use nonce instead of shortUrlSuffix because in reality there are so many different shortUrlSuffixes and what we really care about is the fact that the one we are using is a nonce specifically. Just calling it a shortUrlSuffix means we lose the context of what kind of shortUrlSuffix it is. Another example of this is when in sync 3 we pass shortUrl the resource argument. If we just passed in "resource", we wouldn't actually know what was expiring. It could be a Dunkin coupon or even a carton of milk!

Another thing worth noting is that changing the argument name would also not be good because we'd lose the generality of the functions'/actions' use. It would make our functions/actions not make sense in other contexts, and they would only be useful in this specific case.

## 3. Inclusion of Request
This is because the sync of setting an expiry strictly needs to happen when the shortened URL is created and no other time. Thus, we make the condition in the when statement only dependant on the UrlShortening.register() action which is the only one that actually makes a new shortened URL. Additionally, the setExpiry action ONLY needs the shortUrl output by the register action and so it is only conditioned on that action's completion.

## 4. Fixed Domain
In sync 1, it would just be that when we get a shorten URL request we call the NonceGeneration generate with argument "bit.ly" instead of shortUrlBase. We would also not need any variables from the actual request. Similarly, in sync 2, we would remove shortUrlBase from the request. We should also pass in "bit.ly" instead of shortBaseUrl in the register action. Sync 3 would not need to change.

## 5. Adding a Sync

**sync** handleExpiry <br>
&nbsp;&nbsp;**when** ExpiringResource.expireResource (): (shortUrl) <br>
&nbsp;&nbsp;**then** UrlShortening.delete (shortUrl)

since expireResource is described as something that happens when its resource expires, we wait for it to happen. Then, when it does, we delete the shortUrl associated with the expired timer using the UrlShortening.delete action.

[back to table of contents](/assignments/pset2/contents.md)
